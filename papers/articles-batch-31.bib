@article{rayyan-384038306,
  title={A brief history of cloud application architectures},
  year={2018},
  journal={Applied Sciences (Switzerland)},
  volume={8},
  number={8},
  author={Kratzke, Nane},
  url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051750704&doi=10.3390%2Fapp8081368&partnerID=40&md5=e6d6df371f11d0d5c642c5ca50f89922},
  abstract={This paper presents a review of cloud application architectures and its evolution. It reports observations being made during a research project that tackled the problem to transfer cloud applications between different cloud infrastructures. As a side effect, we learned a lot about commonalities and differences from plenty of different cloud applications which might be of value for cloud software engineers and architects. Throughout the research project, we analyzed industrial cloud standards, performed systematic mapping studies of cloud-native application-related research papers, did action research activities in cloud engineering projects, modeled a cloud application reference model, and performed software and domain-specific language engineering activities. Two primary (and sometimes overlooked) trends can be identified. First, cloud computing and its related application architecture evolution can be seen as a steady process to optimize resource utilization in cloud computing. Second, these resource utilization improvements resulted over time in an architectural evolution of how cloud applications are being built and deployed. A shift from monolithic service-oriented architectures (SOA), via independently deployable microservices towards so-called serverless architectures, is observable. In particular, serverless architectures are more decentralized and distributed, and make more intentional use of separately provided services. In other words, a decentralizing trend in cloud application architectures is observable that emphasizes decentralized architectures known from former peer-to-peer based approaches. This is astonishing because, with the rise of cloud computing (and its centralized service provisioning concept), the research interest in peer-to-peer based approaches (and its decentralizing philosophy) decreased. However, this seems to change. Cloud computing could head into the future of more decentralized and more meshed services. © 2018 Elsevier B.V., All rights reserved.},
  note={Type: Review},
  doi={10.3390/app8081368},
  chapter={0}
}

@article{rayyan-384038309,
  title={Distributed monitoring system for microservices-based {IoT} middleware system},
  year={2018},
  journal={Lecture Notes in Computer Science},
  volume={11063},
  pages={467 -- 477},
  author={Kang, Rui and Zhou, Zhenyu and Liu, Jiahua and Zhou, Zhongran and Xu, Shunwang},
  url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85061230964&doi=10.1007%2F978-3-030-00006-6_43&partnerID=40&md5=c75d0bfd3ce7dc15d255e42865781f1c},
  keywords={Cloud computing, Microservice, Information services, Architecture, Service oriented architecture (SOA), Middleware, Monitoring system, Internet of things, Monitoring, Performance metrics, Distributed monitoring systems, Lightweight middleware, Middleware architecture, Middleware system, Stream processing},
  abstract={Microservices based architecture is a promising middleware architecture of Internet of things for its advantages of agility and scalability. However, comparing to the native Service oriented Architecture (SOA), the widespread nature, no matter logically or physically, of this lightweight middleware system has made its organization, tracing and monitoring much harder, which could further compromise the effectiveness and performance. To this end, we design, implement and evaluate a new distributed monitoring system for microservices-based middleware of Internet of Things, which is designed as a cloud native system. This system is featured with supporting Kubernetes orchestration, instrument Java and Spring Cloud framework and owing the ability to obtain the performance metrics from all host and containers in an efficient way. Furthermore, it could collect the trace generated by a call from application frontend to each layered microservices, even fetching logging, and finally store them in a big data system for stream processing or map/reduce. The real implementation based evaluation has demonstrated the effectiveness of this system design. © 2019 Elsevier B.V., All rights reserved.},
  note={Type: Conference paper},
  doi={10.1007/978-3-030-00006-6_43},
  chapter={0}
}

@article{rayyan-384038310,
  title={Making runtime data useful for incident diagnosis: {An} experience report},
  year={2018},
  journal={Lecture Notes in Computer Science},
  volume={11271},
  pages={422 -- 430},
  author={Lautenschlager, Florian and Ciolkowski, Marcus},
  url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85057277274&doi=10.1007%2F978-3-030-03673-7_33&partnerID=40&md5=cf1173fa619c17544c2d5dc5dd4ae517},
  keywords={Cloud applications, Runtimes, Distributed tracing, Artificial intelligence, DevOps, Clouds, Monitoring, Software systems, Computer science, Computers, Elasticsearch, Experience report, Process engineering, Technical debts},
  abstract={Important and critical aspects of technical debt often surface at runtime only and are difficult to measure statically. This is a particular challenge for cloud applications because of their highly distributed nature. Fortunately, mature frameworks for collecting runtime data exist but need to be integrated. In this paper, we report an experience from a project that implements a cloud application within Kubernetes on Azure. To analyze the runtime data of this software system, we instrumented our services with Zipkin for distributed tracing; with Prometheus and Grafana for analyzing metrics; and with fluentd, Elasticsearch and Kibana for collecting, storing and exploring log files. However, project team members did not utilize these runtime data until we created a unified and simple access using a chat bot. We argue that even though your project collects runtime data, this is not sufficient to guarantee its usage: In order to be useful, a simple, unified access to different data sources is required that should be integrated into tools that are commonly used by team members. © 2019 Elsevier B.V., All rights reserved.},
  note={Type: Conference paper},
  doi={10.1007/978-3-030-03673-7_33},
  chapter={0}
}

@article{rayyan-384038311,
  title={Microservices for the {Enterprise}: {Designing}, {Developing}, and {Deploying}},
  year={2018},
  pages={1 -- 441},
  author={Indrasiri, Kasun and Siriwardana, Prabath},
  url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-105002517137&doi=10.1007%2F978-1-4842-3858-5&partnerID=40&md5=bd3e650bafa51fc1dd7981ce5c3b207a},
  keywords={Application programming interfaces (API), Microservice, Integration, Kubernetes, Distributed tracing, Service mesh, Microservice security, Quality of service, Engineering research, Architecture, Network security, Docker, Edge services, Information management, AMQP, API gateway layer, Composite services, Embedded systems, Enterprise service bus, GRPC, Kafkum, Reactive microservice, Service discovery, Service registry, Servicemesh, Software engineering, Websocket},
  abstract={Understand the key challenges and solutions around building microservices in the enterprise application environment. This book provides a comprehensive understanding of microservices architectural principles and how to use microservices in real-world scenarios. Architectural challenges using microservices with service integration and API management are presented and you learn how to eliminate the use of centralized integration products such as the enterprise service bus (ESB) through the use of composite/integration microservices. Concepts in the book are supported with use cases, and emphasis is put on the reality that most of you are implementing in a “brownfield” environment in which you must implement microservices alongside legacy applications with minimal disruption to your business. Microservices for the Enterprise covers state-of-the-art techniques around microservices messaging, service development and description, service discovery, governance, and data management technologies and guides you through the microservices design process. Also included is the importance of organizing services as core versus atomic, composite versus integration, and API versus edge, and how such organization helps to eliminate the use of a central ESB and expose services through an API gateway. © 2025 Elsevier B.V., All rights reserved.},
  note={Type: Book},
  doi={10.1007/978-1-4842-3858-5},
  chapter={0}
}

@article{rayyan-384038312,
  title={Fault {Diagnosis} for {Microservices} with {Execution} {Trace} {Monitoring}},
  year={2017},
  journal={Ruan Jian Xue Bao/Journal of Software},
  volume={28},
  number={6},
  pages={1435 -- 1454},
  author={Wang, Ziyong and Wang, Tao and Zhang, Wenbo and Chen, Ningjiang and Zuo, Chun},
  url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85027315811&doi=10.13328%2Fj.cnki.jos.005223&partnerID=40&md5=dcffc742c8dd1600017f774be8f47877},
  keywords={Performance and reliabilities, Anomaly detection, Performance anomaly, Performance metrics, Fault detection, Microservices, Dynamic instrumentation, Execution trace, Failure analysis, Financial data processing, Forestry, Principal component analysis, Systems engineering, Tree edit distance},
  abstract={Microservice architecture is gradually adopted by more and more applications. How to effectively detect and locate faults is a key technology to guarantee the performance and reliability of microservices. Current approaches typically monitor physical metrics, and manually set alarm rules according to the domain knowledge. However, these approaches cannot automatically detect faults and locate root causes in fine granularity. To address the above issues, this work proposes a fault diagnosis approach for microservices based on the execution trace monitoring. First, dynamic instrumentation is used to monitor the execution traces crossing service components, and then call trees are used to describe the execution traces of user requests. Second, for the faults affecting the structure of execution traces, the tree edit distance is used to assess the abnormality degree of processing requests, and the method calls leading to failures are located by analyzing the difference between execution traces. Third, for the performance anomalies leading to the response delay, principal component analysis is used to extract the key method invocations causing unusual fluctuations in performance metrics. Experimental results show that this new approach can accurately characterize the execution trace of processing requests, and locate the methods that cause system failures and performance anomalies. © 2017 Elsevier B.V., All rights reserved.},
  note={Type: Article},
  doi={10.13328/j.cnki.jos.005223},
  chapter={0}
}

@article{rayyan-384038313,
  title={A microservice-based portal for {X}-ray transient and variable sources - {CEUR} {Workshop} {Proceedings}},
  year={2016},
  volume={1871},
  author={D’Agostino, Daniele and Roverelli, Luca and Zereik, Gabriele and De Luca, Andrea D. and Salvaterra, Ruben and Belfiore, Andrea and Lisini, Gianni and Novara, Giovanni and Tiengo, Andrea},
  url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025175430&partnerID=40&md5=bf1ea14f933f9d43eb5eb8180230167f},
  keywords={Microservices, Amount of information, Astrophysics, European photon imaging cameras, Science gateway, X-ray transients, Data archives, Temporal domain, Time domain},
  abstract={Modern soft X-ray observatories can yield unique insights into time domain astrophysics, and a huge amount of information is stored - and largely unexploited - in data archives. Like a treasure-hunt, the EXTraS project is harvesting the hitherto unexplored temporal domain information buried in the serendipitous data collected by the European Photon Imaging Camera (EPIC) instrument onboard the ESA XMM-Newton, in 16 years of observations. Part of this analysis is performed through a dedicated science gateway, the EXTraS portal, whose initial release is the subject of this paper. In particular the focus is on its light software architecture, based on the use of microservices, providing a better resilience and more decoupled development lifecycle with respect to the approaches followed by the most used science gateway toolkits. © 2017 Elsevier B.V., All rights reserved.},
  note={Type: Conference paper},
  booktitle={{CEUR} {Workshop} {Proceedings}},
  chapter={0}
}

